JVM 调优分享
场景：在项目中处理大文件，且不因为某个点影响整个系统业务的用户体验。

问题：JVM OOM
问题的原因：在业务中处理的文件是需要把另一个端传过来的oss链接上的pdf下载下来转为图片从而方便前端进行展示。pdf大小在20-300M不等，通常在20M左右。
需要解决的事情：
	1：控制FULL gc的频率，增强用户体验与JVM吞吐率
	2：控制并发防止程序的崩溃。
初步分析：
	1：JVM 使用的是ParNew+CMS，年轻代使用的复制算法
	2：复制算法在对象存活率低的情况下效率是完全优于标记清除的效率的。
初步解决：
	1：调整整个堆大小
	2：调整EDEN大小
	3：调整FROM TO大小
	4：调整对象进入老年代的条件。
这里我们得到的效果是增强了程序的吞吐率。并没有完全的解决问题，因为如果某个时间节点的并发比较高程序没有catch oom的情况下仍然会崩溃。
需要解决并发的问题，那么如果简单的在java内存里面使用同步队列或信号量的方式控制，会引发新的问题，如果程序因为其它原因崩溃会导致调用的数据丢失。
所以我们需要更安全的方式来保障数据：例如基于redis list的队列以及其它类似的中间件，来对请求进行暂存。

终极拷问，在这个业务场景下，这个图片真的有必要存放在堆内存增加JVM的压力吗？答案是没必要。正常FULL GC可能一天执行一次，因为这一个业务点影响到了整个服务的可用性。
终极解决办法：
	1：仍然使用中间件队列的形式控制并发以及请求的数据安全。
	2：使用堆外内存对这个业务进行处理，不影响整个系统的业务。使用完后手动释放。
	3：也要避免因为程序的问题导致堆外内存无法释放，需要设置对外内存的阈值。
	4：需要程序中保障在该模式下不会重复处理请求。

